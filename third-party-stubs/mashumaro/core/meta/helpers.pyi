import typing
from typing import Any, Dict, Optional, Sequence, Tuple, Type

def get_type_origin(typ: Type) -> Type: ...
def get_generic_name(typ: Type, short: bool = ...) -> str: ...
def get_args(typ: Optional[Type]) -> Tuple[Type, ...]: ...
def get_literal_values(typ: Type) -> Tuple[Any, ...]: ...
def type_name(
    typ: Optional[Type],
    short: bool = ...,
    resolved_type_params: Optional[Dict[Type, Type]] = ...,
    is_type_origin: bool = ...,
    none_type_as_none: bool = ...,
) -> str: ...
def is_special_typing_primitive(typ: Any) -> bool: ...
def is_generic(typ: Type) -> bool: ...
def is_typed_dict(typ: Type) -> bool: ...
def is_named_tuple(typ: Type) -> bool: ...
def is_new_type(typ: Type) -> bool: ...
def is_union(typ: Type) -> bool: ...
def is_optional(typ: Type, resolved_type_params: Optional[Dict[Type, Type]] = ...) -> bool: ...
def is_annotated(typ: Type) -> bool: ...
def get_type_annotations(typ: Type) -> Sequence[Any]: ...
def is_literal(typ: Type) -> bool: ...
def not_none_type_arg(
    type_args: Tuple[Type, ...], resolved_type_params: Optional[Dict[Type, Type]] = ...
) -> Optional[Type]: ...
def is_type_var(typ: Type) -> bool: ...
def is_type_var_any(typ: Type) -> bool: ...
def is_class_var(typ: Type) -> bool: ...
def is_final(typ: Type) -> bool: ...
def is_init_var(typ: Type) -> bool: ...
def get_class_that_defines_method(method_name: str, cls: Type) -> Optional[Type]: ...
def get_class_that_defines_field(field_name: str, cls: Type) -> Optional[Type]: ...
def is_dataclass_dict_mixin(typ: Type) -> bool: ...
def is_dataclass_dict_mixin_subclass(typ: Type) -> bool: ...
def collect_type_params(typ: Type) -> Sequence[Type]: ...
def resolve_type_params(
    typ: Type, type_args: Sequence[Type] = ..., include_bases: bool = ...
) -> Dict[Type, Dict[Type, Type]]: ...
def substitute_type_params(typ: Type, substitutions: Dict[Type, Type]) -> Type: ...
def get_name_error_name(e: NameError) -> str: ...
def is_dialect_subclass(typ: Type) -> bool: ...
def is_self(typ: Type) -> bool: ...
def is_required(typ: Type) -> bool: ...
def is_not_required(typ: Type) -> bool: ...
def get_function_arg_annotation(
    function: typing.Callable[[Any], Any],
    arg_name: typing.Optional[str] = ...,
    arg_pos: typing.Optional[int] = ...,
) -> typing.Type: ...
def get_function_return_annotation(
    function: typing.Callable[[typing.Any], typing.Any]
) -> typing.Type: ...
def is_unpack(typ: Type) -> bool: ...
def is_type_var_tuple(typ: Type) -> bool: ...
def hash_type_args(type_args: typing.Iterable[typing.Type]) -> str: ...
def iter_all_subclasses(cls) -> typing.Iterator[Type]: ...
